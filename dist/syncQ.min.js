!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.syncQ=t():e.syncQ=t()}(window,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t){
/**
 * @Author JC Durbin
 * @License Licensed under the MIT license
 * <LICENSE-MIT or http://opensource.org/licenses/MIT>
 * This file may not be copied, modified, or distributed
 * except according to those terms.
 *
 * syncFetch creates an array of async fetch() requests and manages them as a syncronous queue
 * For a situation where you need syncronous reqeusts but still want the yummy goodness of promises
 */
e.exports=()=>{"use strict";let e=[],t=!1;const r=r=>{r.responseType=r.responseType||"json",r.maxRetries=r.maxRetries||3,r.priority?e.unshift(r):e.push(r),r.debug&&r.debugData(`Queue length: ${e.length} | Item added: ${JSON.stringify(r)}`),t||n()};const n=async()=>{if(0===e.length)return void(t=!1);t=!0;let o=e.shift();try{const e=await fetch(o.url,{});if(!e)throw"Null Return";(async({item:e,response:t})=>{let r={result:t};if("json"===e.responseType?r.content=await t.json():r.content=await t.text(),e.header){let n=[];e.headers.forEach(async e=>{n.push({[e]:await t.headers.get(e)})}),r.headers=n}e.success(r),n()})({item:o,response:e})}catch(e){(({item:e,err:t})=>{e.debug&&e.debugData(`Error - request failed: ${t} | Item: ${e}`),e.retryCount||(e.retryCount=0),e.retry&&e.retryCount<e.maxRetries?(e.retryCount++,e.debug&&e.debugData(`Retry: ${e.retryCount} of ${e.maxRetries} | Item: ${e}`),r(e)):(e.fail(t),e.debug&&e.debugData("Max retries reached | Item: "+JSON.stringify(e))),n()})({item:o,err:e})}};return{queue:e,add:r,remove:()=>{},clearAll:function(){t=!1,e.length=0,console.log("QUEUE",e.length)},clearByName:t=>{e=e.filter((function(e){if(e.name)return e.name==t}))}}}}])}));
//# sourceMappingURL=syncQ.min.js.map